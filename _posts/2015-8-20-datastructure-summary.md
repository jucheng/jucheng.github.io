---
layout: post
title: "阿里巴巴2015实习生笔试真题 "
date: 2015-8-20
categories: 数据结构
tags: [数据结构，综合]
---
阿里巴巴2015实习生笔试真题

<!-- more -->

![](http://img-storage.qiniudn.com/15-8-19/67376187.jpg)

**解析：**

**循环队列有对头指针和对尾指针，但是循环队列也是线性结构的；**

**在循环队列中，元素的动态变化是通过对头指针和对尾指针共同决定的**

**队列、栈、链表、数组都是是线性结构**

**队列(Queue)也是一种运算受限的线性表。它只允许在表的一端进行插入，而在另一端进行删除。**

**循环队列是将顺序队列首尾相连形成的，随着插入元素或删除元素的进行，其队头指针及队尾指针是在不断变化的，有时可能会出现队头指针大于队尾指针的情况，也可能是队尾指针大于队头指针。**

![](http://img-storage.qiniudn.com/15-8-19/21665440.jpg)

**解析：**

**常用的精简指令集 RISC 微处理器包括 DECAlpha 、 ARC 、 ARM 、 AVR 、 MIPS 、 PA-RISC 、 PowerArchitecture( 包括 PowerPC) 和 SPARC 等。**

**复杂指令 CISC如X86。**

![](http://img-storage.qiniudn.com/15-8-19/65319157.jpg)

这道题的答案是Ａ，但是在牛客网上很多人在相关评论中都说应该是Ｂ

我们来看看传统的分块矩阵相乘：

![](http://img-storage.qiniudn.com/15-8-19/88793602.jpg)

**很明显依然是行乘以列的方式。**

**再来看看Strassen矩阵相乘：**

**同样是分块，只是计算方式不同**

![](http://img-storage.qiniudn.com/15-8-19/40846370.jpg)

很明显，涉及到行的加法(a+b,c+d,e+f,g+h)，列的减法(f-h,g-e,b-d,a-c)，对角线的加法(a+d,e+h)以及行列的乘法，所以无论是

A按行存，B按行存。

A按行存，B按列存。

计算速度都是差不多的。

**而如果用的是传统矩阵相乘法，按B选项的方式存储计算速度更快**。综上所述，我觉得答案应该选B。

![](http://img-storage.qiniudn.com/15-8-19/31433399.jpg)

**解析：**

**a) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。** 

**b) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。** 

**c) 网络字节序：TCP/IP各层协议将字节序定义为Big-Endian，因此TCP/IP协议中使用的字节序通常称之为网络字节序。**


**其实 big endian 是指低地址存放最高有效字节（ MSB ），而 little endian 则是低地址存放最低有效字节（ LSB ）。 所有网络协议也都是采用 big endian 的方式来传输数据的。所以有时我们也会把 big endian 方式称之为网络字节序。当两台采用不同字节序的主机通信时，在发送数据之前都必须经过字节序的转换成为网络字节序后再进 行传输。**

![](http://img-storage.qiniudn.com/15-8-19/85259103.jpg)

![](http://img-storage.qiniudn.com/15-8-19/10532397.jpg)

**解析：**

![](http://img-storage.qiniudn.com/15-8-19/48059680.jpg)

![](http://img-storage.qiniudn.com/15-8-19/13634433.jpg)

![](http://img-storage.qiniudn.com/15-8-20/32981830.jpg)

**解析:**

**shell排序的平均复杂度是O(nlogn)~O(n2)     最好的情况O(n1.3)，最坏的情况O(n2)**

**快速排序的平均复杂度是O(nlogn)，          最好的情况O(nlogn)，最坏的情况O(n2)**

**直接插入排序的平均复杂度是O(n2)，         最好的情况O(n)，    最坏的情况O(n2)**

**冒泡排序的平均复杂度是O(n2),              最好的情况O(n),    最坏的情况O(n2)**

![](http://img-storage.qiniudn.com/15-8-20/4308541.jpg)

解析：

**用求轴点的方法，看前后分割的数组下标，找到第k的位置，然后将其他值与k位置的值比较，若值比k大不动，比k小扔前面，这样比较n次就能找到**

(虽然这个答案是我觉得在相关的题目里边评论比较好的一个，但是，我还是没能很好的理解这道题，所以，暂时先放下，回头再看，说不定效果会好一些！！！）

![](http://img-storage.qiniudn.com/15-8-20/62200754.jpg)

**解析：**

**假设集合A，以及基于A上的关系R** 

**自反： 如果a是A的元素，那么<a,a>是R的元素** 

**反自反： 如果a是A的元素，那么<a,a>不是R的元素** 

**对称：如果<a,b>是R的元素，那么<b,a>是R的元素** 

**反对称：如果<a,b>，<b,a>是R的元素，那么a,b相等**
 
**传递：如果<a,b>，<b,c>是R的元素，那么<a,c>是R的元素**

![](http://img-storage.qiniudn.com/15-8-20/62583978.jpg)

解析：

**最朴素最简单的原语   CAS(compare-and-swap)   操作即可以完成所有的无锁功能，其他的如   LL/SC (load linked/store conditional)   。**

![](http://img-storage.qiniudn.com/15-8-20/69991592.jpg)

解析：

**确认序列号=原始序列号+TCP段的长度**

其实是1001，但是其他差距太远了，勉强选D吧

**TCP的报文到达确认（ACK），是对接收到的数据的最高序列号的确认，并向发送端返回一个下次接收时期望的TCP数据包的序列号（Ack Number）。例如，主机A发送的当前数据序号是400，数据长度是100，则接收端收到后会返回一个确认号是501的确认号给主机A。**

![](http://img-storage.qiniudn.com/15-8-20/72576129.jpg)

**异步是软中断，内核中有一些消息集，异步就是发送这些消息给内核。是内核的一种机制，与IO无关**

**A：可以提高集群中不同主机之间的网络I/O效率**

**B：设计到一个任务本地性的概念，减少跨主机，跨机架的I/O数据量**

**D的话， 能提升性能， 但是不能提升读写性能**

![](http://img-storage.qiniudn.com/15-8-20/31168565.jpg)

**解析：**

![](http://img-storage.qiniudn.com/15-8-20/4728578.jpg)

![](http://img-storage.qiniudn.com/15-8-20/59070413.jpg)

**解析：**

**有公式：N2=N0-1，度为2的节点个数是度为0的节点个数减一，所以N0=3，则N2=2，再加上N1=8，总的是13**

![](http://img-storage.qiniudn.com/15-8-20/3006046.jpg)

解析：

#####10个糖果依次排开，中间有9个空挡 ，依次编号为空挡1-9，从这9个空挡中任意取出2 个作为分割点 ，正好能把糖果分为3份，并且保证每一份中至少有一个糖果。因为分割点并没有顺序，所以可以使用组合公式C(9,2)计算。

![](http://img-storage.qiniudn.com/15-8-20/88726809.jpg)

![](http://img-storage.qiniudn.com/15-8-20/58288631.jpg)

解析：

**我的理解是x每次与x-1进行一次与（&）操作，就会导致x二进制中的1减少一个。通过函数fun可知，x二进制中有多少位1就会进行多少次与计算。**

**500的二进制表示是：111110100，共有6个1。所以答案是6**

![](http://img-storage.qiniudn.com/15-8-20/16977309.jpg)

解析：
创建进程的整个流程：

**1,申请空白PCB（进程控制块）；**

**2,为新进程分派资源；**

**3,初始化PCB；**

**4,将新进程插入就绪队列；**

![](http://img-storage.qiniudn.com/15-8-20/17649560.jpg)

![](http://img-storage.qiniudn.com/15-8-20/23626857.jpg)

**解析：**

#####%x是按十六进制输出，++*x = 26 = 0x1a
