---
layout: post
title: " 计算机算法：Strassen矩阵相乘算法 "
date: 2015-8-19
categories: 算法
tags: [算法]
---
计算机算法：Strassen矩阵相乘算法

<!-- more -->

引言

Strassen的矩阵相乘方法是一种典型的分治算法。目前为止，我们已经见过一些分治策略的算法了，例如归并排序和Karatsuba大数快速乘法。现在，让我再来看看分治策略的背后是什么。

同动态规划不同，在动态规划中，为了得到最终的解决方案，我们经常需要把一个大的问题“展开”为几个子问题，但是这里，我们会更多的谈到如何把一些子解决方案组合到一起。这些子问题的解决方案是对等的，他们的归并方式也是通过某种方式定义好的。

一个典型的例子就是归并排序算法。在归并排序中，我们有两个有序数组，我们想要这两个数组在合并之后仍然保持有序。当然了，在归并排序中，最复杂的部分当属自我合并，而原因在于，我们不得不传递两个数组，A和B，然后去比较每一“对”分别来自数组A和数组B的元素。有一点离题，但是，这是归并排序的一个弱点，虽然，它的最坏情况的时间复杂度是 O(n.log(n))，但是，快速排序却往往是实践中更为有效的排序方法，因为，它没有“合并”的过程。快速排序仅仅把两个子数组连接到一起，请注意，在快速排序中，子数组一般并不具有相同的长度，虽然他的最坏时间复杂度是O(n^2)，但它的性能却经常好于归并排序。

在上文中，那个简单的例子告诉我们：有时候如何合并两个子问题并不是一个简单的事情。因此，当我们使用分治策略的时候，我们必须非常谨慎。

历史

Volker Strassen是一位出生于1936年的德国数学家。他因为在概率论上的工作而广为人知，但是在计算机科学和算法领域，他却因为矩阵相乘算法而被大部分人认识，这个算法目前仍然是比通用矩阵相乘算法性能好的主要算法之一。

Strassen在1969年第一次发表关于这个算法的文章，并证明了复杂度为n^3的算法并不是最优算法。实际上，Strassen给出的解决方案只是更好一点点，但是，他的贡献却是巨大的，因为他的工作触发了矩阵相乘领域更多的研究，比如复杂度为O(n^2,3737)的Coppersmith-Winograd算法。

概述

两个矩阵 A[NxN] 和 B[NxN] 相乘的通用算法是非常简单的。虽然矩阵相乘比两个数字相乘要复杂得多，而且也不满足交换律，但它仍然非常简单——同时也很慢。

让我们先来定义一下什么是A[NxN]矩阵。因为我们要说下NxN矩阵，让我们先想象一个有N行N列的方格网。在每一行和每一列的A[i][j]，我们都有一个值。

![](http://img-storage.qiniudn.com/15-8-19/53966358.jpg)

当然，作为一个开发者，我们可以把一个矩阵看成一个二维数组。
   
    // PHP two-dimensional array
    $a = array(
    0 => array($v1, $v2, $v3, $v4),
    1 => array($v5, $v6, $v7, $v8),
    2 => array($v9, $v10, $v11, $v12),
    );

不要忘记，一个NxN的矩阵仅仅是矩阵中的一种情况，同样的，我们可以有其他任何大小的NxM阶矩阵(N <> M)。

然而，为了和另外的矩阵相乘，矩阵的大小是非常重要的，为什么？

正如我上面提到的一样，矩阵相乘和数字相乘并不一样。首先，这个操作并不满足交换律。

![](http://img-storage.qiniudn.com/15-8-19/59612626.jpg)

第二个问题是，你用来相乘A和B的方法。

![](http://img-storage.qiniudn.com/15-8-19/82101148.jpg)

仅仅因为这种方法只对NxN阶矩阵有效，因此我们能看到把矩形矩阵相乘产生的问题。确实，这是不可能的，除非A矩阵的第二维和B矩阵的第一维相等。

![](http://img-storage.qiniudn.com/15-8-19/92004723.jpg)

不过好在我们现在正在讨论的是具有相同维数的方形矩阵。

好的，现在我们知道如何把两个方形矩阵相乘了（具有相同维数NxN），现在，让我们一起去估算一下通用矩阵相乘算法的时间复杂度。

我们知道A.B = C，当且仅当：

    C[i][j] = sum(A[i][k] * B[k][j]) for k = 0 .. n

于是，我们有一个n^3复杂度的操作。现在，让我们尽力找一个分治策略的算法。

这个对于矩阵来说确实并不难，因为我们知道，一个矩阵可以被分成很多更小的子矩阵。

![](http://img-storage.qiniudn.com/15-8-19/79565169.jpg)

现在，我们有什么？

![](http://img-storage.qiniudn.com/15-8-19/88793602.jpg)

再一次——同样的时间复杂度——我们有了8个乘积和4个和，那么，计算量在哪？

当然， 为了得到更快的解决方案，我们不得不看一下Strassen在1969做过的工作。他如下图定义了P1, P2, P3, P4, P5, P6 和 P7。

![](http://img-storage.qiniudn.com/15-8-19/40846370.jpg)

时间复杂度

正如我以上提到的，Strassen算法仅仅比通用矩阵相乘算法好一点点。通用矩阵相乘算法时间复杂度是O(n^3)，然而Strassen算法复杂度则是O(n^2.80)。

你能在下图观察到，随着n的变大，Strassen算法是如何比通用矩阵相乘算法变得更有效率的。

![](http://img-storage.qiniudn.com/15-8-19/77948516.jpg)

应用

虽然这个算法看起来更接近纯数学领域，而不是计算机领域。但在实际应用中，任何用到NxN数组的地方，我们都可以从矩阵相乘算法中获益。

另一方面，Strassen算法并不比n^3复杂度的通用矩阵相乘算法快很多。这很重要，因为对于一个很小的n(通常n<45)来说，通用矩阵相乘算法在实践中往往是更好的选择。然而，你可以从以上的图片中看到，对于n>100的情况来说，这两个算法的差别还是相当大的。

![](http://img-storage.qiniudn.com/15-8-19/19119851.jpg)

原文链接：

<http://www.ituring.com.cn/article/17978>