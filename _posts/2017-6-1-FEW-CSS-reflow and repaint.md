---
layout: post
title: "高性能JavaScript 重排与重绘"
date: 2017-6-1
categories: 前端
tags: [前端开发，CSS]
---

高性能JavaScript 重排与重绘

![](http://oq2sjn05e.bkt.clouddn.com/2017-6-1-FEW-CSS-reflow%20and%20repaint.jpg)

<!-- more -->

### 一、前言

先回顾下《高性能JavaScript DOM编程》，主要提了两点优化，一是尽量减少DOM的访问，而把运算放在ECMAScript这一端，二是尽量缓存局部变量，比如length等等，最后介绍了两个新的API querySelector()以及querySelectorAll()，在做组合选择的时候可以大胆使用。而本文主要讲的是DOM编程可能最耗时的地方，重排和重绘。

### 二、什么是重排和重绘

浏览器下载完页面中的所有组件——HTML标记、JavaScript、CSS、图片之后会解析生成两个内部数据结构——DOM树和渲染树。

DOM树表示页面结构，渲染树表示DOM节点如何显示。DOM树中的每一个需要显示的节点在渲染树种至少存在一个对应的节点（隐藏的DOM元素disply值为none 在渲染树中没有对应的节点）。渲染树中的节点被称为“帧”或“盒”,符合CSS模型的定义，理解页面元素为一个具有填充，边距，边框和位置的盒子。一旦DOM和渲染树构建完成，浏览器就开始显示（绘制）页面元素。

当DOM的变化影响了元素的几何属性（宽或高），浏览器需要重新计算元素的几何属性，同样其他元素的几何属性和位置也会因此受到影响。

**浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。这个过程称为重排。**

**完成重排后，浏览器会重新绘制受影响的部分到屏幕，该过程称为重绘。**

由于浏览器的流布局，对渲染树的计算通常只需要遍历一次就可以完成。但table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。这也是为什么我们要避免使用table做布局的一个原因。

并不是所有的DOM变化都会影响几何属性，比如改变一个元素的背景色并不会影响元素的宽和高，这种情况下只会发生重绘。

### 三、重排何时发生

很显然，每次重排，必然会导致重绘，那么，重排会在哪些情况下发生？

+ 添加或者删除可见的DOM元素
+ 元素位置改变
+ 元素尺寸改变
+ 元素内容改变（例如：一个文本被另一个不同尺寸的图片替代）
+ 页面渲染初始化（这个无法避免）
+ 浏览器窗口尺寸改变

这些都是显而易见的，或许你已经有过这样的体会，不间断地改变浏览器窗口大小，导致UI反应迟钝（某些低版本IE下甚至直接挂掉），现在你可能恍然大悟，没错，正是一次次的重排重绘导致的！

**网页生成的时候，至少会渲染一次。用户访问的过程中，还会不断重新渲染。**

**重新渲染，就需要重新生成布局和重新绘制。前者叫做"重排"（reflow），后者叫做"重绘"（repaint）。**

**需要注意的是，"重绘"不一定需要"重排"，比如改变某个网页元素的颜色，就只会触发"重绘"，不会触发"重排"，因为布局没有改变。但是，"重排"必然导致"重绘"，比如改变一个网页元素的位置，就会同时触发"重排"和"重绘"，因为布局改变了。**

### 四、渲染树变化的排队和刷新

思考下面代码：

![](http://oq2sjn05e.bkt.clouddn.com/2017-6-1-FEW-CSS-reflow%20and%20repaint-1.png)

乍一想，元素的样式改变了三次，每次改变都会引起重排和重绘，所以总共有三次重排重绘过程，**但是浏览器并不会这么笨，它会把三次修改“保存”起来（大多数浏览器通过队列化修改并批量执行来优化重排过程），一次完成！**

但是，有些时候你可能会（经常是不知不觉）强制刷新队列并要求计划任务立即执行。获取布局信息的操作会导致队列刷新，比如：

+ offsetTop, offsetLeft, offsetWidth, offsetHeight
+ scrollTop, scrollLeft, scrollWidth, scrollHeight
+ clientTop, clientLeft, clientWidth, clientHeight
+ getComputedStyle() (currentStyle in IE)

将上面的代码稍加修改：

![](http://oq2sjn05e.bkt.clouddn.com/2017-6-1-FEW-CSS-reflow%20and%20repaint-2.png)

因为offsetHeight属性需要返回最新的布局信息，因此浏览器不得不执行渲染队列中的“待处理变化”并触发重排以返回正确的值（即使队列中改变的样式属性和想要获取的属性值并没有什么关系），所以上面的代码，前两次的操作会缓存在渲染队列中待处理，但是一旦offsetHeight属性被请求了，队列就会立即执行，所以总共有两次重排与重绘。

**所以尽量不要在布局信息改变时做查询。**

### 五、最小化重排和重绘

我们还是看上面的这段代码：

![](http://oq2sjn05e.bkt.clouddn.com/2017-6-1-FEW-CSS-reflow%20and%20repaint-1.png)

三个样式属性被改变，每一个都会影响元素的几何结构，虽然大部分现代浏览器都做了优化，只会引起一次重排，但是像上文一样，如果一个及时的属性被请求，那么就会强制刷新队列，而且这段代码四次访问DOM，一个很显然的优化策略就是把它们的操作合成一次，这样只会修改DOM一次：

![](http://oq2sjn05e.bkt.clouddn.com/2017-6-1-FEW-CSS-reflow%20and%20repaint-3.png)

### 六、fragment元素的应用

看如下代码，考虑一个问题：

![](http://oq2sjn05e.bkt.clouddn.com/2017-6-1-FEW-CSS-reflow%20and%20repaint-4.png)

如果代码中要添加内容为peach、watermelon两个选项，你会怎么做？

![](http://oq2sjn05e.bkt.clouddn.com/2017-6-1-FEW-CSS-reflow%20and%20repaint-5.png)

很容易想到如上代码，但是很显然，重排了两次，怎么破？前面我们说了，隐藏的元素不在渲染树中，太棒了，我们可以先把id为fruit的ul元素隐藏（display=none)，然后添加li元素，最后再显示，**但是实际操作中可能会出现闪动**，原因这也很容易理解。这时，fragment元素就有了用武之地了。

![](http://oq2sjn05e.bkt.clouddn.com/2017-6-1-FEW-CSS-reflow%20and%20repaint-6.png)

**文档片段是个轻量级的document对象，它的设计初衷就是为了完成这类任务——更新和移动节点。文档片段的一个便利的语法特性是当你附加一个片断到节点时，实际上被添加的是该片断的子节点，而不是片断本身。只触发了一次重排，而且只访问了一次实时的DOM。**

### 七、让元素脱离动画流

用展开/折叠的方式来显示和隐藏部分页面是一种常见的交互模式。它通常包括展开区域的几何动画，并将页面其他部分推向下方。

一般来说，重排只影响渲染树中的一小部分，但也可能影响很大的部分，甚至整个渲染树。浏览器所需要重排的次数越少，应用程序的响应速度就越快。因此当页面顶部的一个动画推移页面整个余下的部分时，会导致一次代价昂贵的大规模重排，让用户感到页面一顿一顿的。渲染树中需要重新计算的节点越多，情况就会越糟。

使用以下步骤可以避免页面中的大部分重排：

+ 使用绝对位置定位页面上的动画元素，将其脱离文档流
+ 让元素动起来。当它扩大时，会临时覆盖部分页面。但这只是页面一个小区域的重绘过程，不会产生重排并重绘页面的大部分内容。
+ 当动画结束时恢复定位，从而只会下移一次文档的其他元素


### 八、提高性能的九个技巧

有一些技巧，可以降低浏览器重新渲染的频率和成本。

**第一条，DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。**

**第二条，如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排。**

**第三条，不要一条条地改变样式，而要通过改变class，或者csstext属性，一次性地改变样式。**

![](http://oq2sjn05e.bkt.clouddn.com/2017-6-1-FEW-CSS-reflow%20and%20repaint-7.png)

**第四条，尽量使用离线DOM，而不是真实的网面DOM，来改变元素样式。**比如，操作Document Fragment对象，完成后再把这个对象加入DOM。再比如，使用 cloneNode() 方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。

**第五条，先将元素设为display: none（需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）**。这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。

**第六条，position属性为absolute或fixed的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。**

**第七条，只在必要的时候，才将元素的display属性为可见，因为不可见的元素不影响重排和重绘**。另外，visibility : hidden的元素只对重绘有影响，不影响重排。

**第八条，使用虚拟DOM的脚本库**，比如React等。

**第九条，使用 window.requestAnimationFrame()、window.requestIdleCallback() 这两个方法调节重新渲染（详见后文）。**

### 九、总结

重排和重绘是DOM编程中耗能的主要原因之一，平时涉及DOM编程时可以参考以下几点：

+ **尽量不要在布局信息改变时做查询（会导致渲染队列强制刷新）**

+ **同一个DOM的多个属性改变可以写在一起（减少DOM访问，同时把强制渲染队列刷新的风险降为0）**

+ **如果要批量添加DOM，可以先让元素脱离文档流，操作完后再带入文档流，这样只会触发一次重排（fragment元素的应用）**


+ **将需要多次重排的元素，position属性设为absolute或fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位。**

本文借鉴于以下文章，十分感谢：

<a href="http://web.jobbole.com/83164/">高性能JavaScript 重排与重绘</a>

<a href="http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html">阮一峰-网页性能管理详解</a>
