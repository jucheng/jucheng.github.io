---
layout: post
title: " 插入排序之-直接插入排序基本思想"
date: 2015-8-20
categories: 算法
tags: [算法]
---
插入排序之-直接插入排序基本思想

<!-- more -->

**插入排序(Insertion Sort)的基本思想是：每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子文件中的适当位置，直到全部记录插入完成为止。**

**本节介绍两种插入排序方法：直接插入排序和希尔排序。**

直接插入排序基本思想

####1、基本思想

假设待排序的记录存放在数组R[1..n]中。初始时，R[1]自成1个有序区，无序区为R[2..n]。从i=2起直至i=n为止，依次将R[i]插入当前的有序区R[1..i-1]中，生成含n个记录的有序区。

####2、第i-1趟直接插入排序：

通常将一个记录R[i](i=2，3，…，n-1)插入到当前的有序区，使得插入后仍保证该区间里的记录是按关键字有序的操作称第i-1趟直接插入排序。

排序过程的某一中间时刻，R被划分成两个子区间R[1．．i-1]（已排好序的有序区）和R[i．．n]（当前未排序的部分，可称无序区）。

直接插入排序的基本操作是将当前无序区的第1个记录R[i]插人到有序区R[1．．i-1]中适当的位置上，使R[1．．i]变为新的有序区。因为这种方法每次使有序区增加1个记录，通常称增量法。

插入排序与打扑克时整理手上的牌非常类似。摸来的第1张牌无须整理，此后每次从桌上的牌(无序区)中摸最上面的1张并插入左手的牌(有序区)中正确的位置上。为了找到这个正确的位置，须自左向右(或自右向左)将摸来的牌与左手中已有的牌逐一比较。

###一趟直接插入排序方法

####1．简单方法

首先在当前有序区R[1..i-1]中查找R[i]的正确插入位置k(1≤k≤i-1)；然后将R[k．．i-1]中的记录均后移一个位置，腾出k位置上的空间插入R[i]。

注意：

若R[i]的关键字大于等于R[1．．i-1]中所有记录的关键字，则R[i]就是插入原位置。

####2．改进的方法

一种查找比较操作和记录移动操作交替地进行的方法。

具体做法：

**将待插入记录R[i]的关键字从右向左依次与有序区中记录R[j](j=i-1，i-2，…，1)的关键字进行比较：**

**①若R[j]的关键字大于R[i]的关键字，则将R[j]后移一个位置；**

**②若R[j]的关键字小于或等于R[i]的关键字，则查找过程结束，j+1即为R[i]的插入位置。**

**关键字比R[i]的关键字大的记录均已后移，所以j+1的位置已经腾空，只要将R[i]直接插入此位置即可完成一趟直接插入排序。**

直接插入排序算法

1．算法描述

    void lnsertSort(SeqList R)
    { //对顺序表R中的记录R[1..n]按递增序进行插入排序
    int i，j；
    for(i=2;i<=n；i++) //依次插入R[2]，…，R[n]
      if(R[i].key<R[i-1].key){//若R[i].key大于等于有序区中所有的keys，则R[i]
                              //应在原有位置上
        R[0]=R[i];j=i-1; //R[0]是哨兵，且是R[i]的副本
        do{ //从右向左在有序区R[1．．i-1]中查找R[i]的插入位置
         R[j+1]=R[j]； //将关键字大于R[i].key的记录后移
         j-- ；
         }while(R[0].key<R[j].key)； //当R[i].key≥R[j].key时终止
        R[j+1]=R[0]； //R[i]插入到正确的位置上
       }//endif
    }//InsertSort


####2．哨兵的作用

算法中引进的附加记录R[0]称监视哨或哨兵(Sentinel)。

哨兵有两个作用：

**①进人查找(插入位置)循环之前，它保存了R[i]的副本，使不致于因记录后移而丢失R[i]的内容；**

**② 它的主要作用是：在查找循环中"监视"下标变量j是否越界。一旦越界(即j=0)，因为R[0].key和自己比较，循环判定条件不成立使得查找循环结束，从而避免了在该循环内的每一次均要检测j是否越界(即省略了循环判定条件"j>=1")。**

注意：

 **①实际上，一切为简化边界条件而引入的附加结点(元素)均可称为哨兵。**

【例】单链表中的头结点实际上是一个哨兵

**② 引入哨兵后使得测试查找循环条件的时间大约减少了一半，所以对于记录数较大的文件节约的时间就相当可观。**对于类似于排序这样使用频率非常高的算法，要尽可能地减少其运行时间。所以不能把上述算法中的哨兵视为雕虫小技，而应该深刻理解并掌握这种技巧。

给定输入实例的排序过程

设待排序的文件有8个记录，其关键字分别为：49，38，65，97，76，13，27，49。为了区别两个相同的关键字49，后一个49的下方加了一下划线以示区别。其排序过程见

【动画模拟演示<http://student.zjzk.cn/course_ware/data_structure/web/flashhtml/insertsort.htm>】

###算法分析


####1．算法的时间性能分析 

对于具有n个记录的文件，要进行n-1趟排序。

各种状态下的时间复杂度：

![](http://img-storage.qiniudn.com/15-8-20/73160717.jpg)

注意：

初始文件按关键字递增有序，简称"正序"。

初始文件按关键字递减有序，简称"反序"。 

####2．算法的空间复杂度分析

算法所需的辅助空间是一个监视哨，辅助空间复杂度S(n)=O(1)。是一个就地排序。

####3．直接插入排序的稳定性

直接插入排序是稳定的排序方法。