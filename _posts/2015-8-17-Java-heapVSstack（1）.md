---
layout: post
title: "Java编程语言中栈与堆内存区别详解"
date: 2015-8-17
categories: Java
tags: [Java，基础知识]
---
Java编程语言中栈与堆内存区别详解

<!-- more -->

一直以来对java中堆和栈都有点模糊：现在终于搞明白啦

特点：

###1.栈的特点是 ：

  **容量小 速度快 适合存放小型数据**

  **如基本数据类型和对象类型的引用**

  **在栈中变量直接指向存放变量值的空间 对于对象引用则存放对象在堆中的内存地址**

 

###2.堆的特点和栈相反 :

 **因此适合存放对象本身**

 

###3.对象引用访问对象的原理是 :

  **先通过该引用找到栈中的数据 即对象的地址 在通过该地址访问对象 这就是为什么
  对象 a=null; 调用a.方法(属性) 会引发异常** 

  **因为找不到实际对象的地址** 


Java编程语言把内存分成两种，一种叫做栈内存，一种叫做堆内存。

**Java的堆是一个运行时数据区,类的对象从中分配空间。这些对象通过new、newarray、anewarray和multianewarray等指令建立，它们不需要程序代码来显式的释放。堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。**

**栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性**。

**栈中主要存放一些基本类型的变量（,int, short, long, byte, float, double, boolean, char）和对象句柄。**

**栈有一个很重要的特殊性，就是存在栈中的数据可以共享**。假设我们同时定义：

   int a = 3;

   int b = 3；

编译器先处理int a =3；首先它会在栈中创建一个变量为a的引用，然后查找栈中是否有3这个值，如果没找到，就将3存放进来，然后将a指向3。接着处理int b = 3；在创建完b的引用变量后，因为在栈中已经有3这个值，便将b直接指向3。这样，就出现了a与b同时均指向3的情况。

这时，如果再令a=4；那么编译器会重新搜索栈中是否有4值，如果没有，则将4存放进来，并令a指向4；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。

**西安达内Java培训讲师表示，要注意这种数据的共享与两个对象的引用同时指向一个对象的这种共享是不同的，因为这种情况a的修改并不会影响到b,它是由编译器完成的，它有利于节省空间。而一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量。**

   String是一个特殊的包装类数据。可以用：

   String str = new String("abc");

   String str = "abc";

复制代码

两种的形式来创建，第一种是用new()来新建对象的，它会在存放于堆中。每调用一次就会创建一个新的对象。

而第二种是先在栈中创建一个对String类的对象引用变量str，然后查找栈中有没有存放"abc"，如果没有，则将"abc"存放进栈，并令str指向”abc”，如果已经有”abc”则直接令str指向“abc”。

**比较类里面的数值是否相等时，用equals()方法；当测试两个包装类的引用是否指向同一个对象时，用==，**下面用例子说明上面的理论。

   String str1 = "abc";

   String str2 = "abc";

   System.out.println(str1==str2); //true

复制代码

可以看出str1和str2是指向同一个对象的。

   String str1 =new String ("abc");

   String str2 =new String ("abc");

   System.out.println(str1==str2); // false

复制代码

用new的方式是生成不同的对象。每一次生成一个。

因此用第一种方式创建多个”abc”字符串,在内存中其实只存在一个对象而已.这种写法有利与节省内存空间.同时它可以在一定程度上提高程序的运行速度，因为JVM会自动根据栈中数据的实际情况来决定是否有必要创建新对象。

而对于String str = new String("abc")；的代码，则一概在堆中创建新对象，而不管其字符串值是否相等，是否有必要创建新对象，从而加重了程序的负担。

**另一方面,要注意:我们在使用诸如Stringstr = "abc"；的格式定义类时，总是想当然地认为，创建了String类的对象str。担心陷阱！对象可能并没有被创建！而可能只是指向一个先前已经创建的对象。只有通过new()方法才能保证每次都创建一个新的对象。**

**由于String类的immutable性质，当String变量需要经常变换其值时，应该考虑使用StringBuffer类，以提高程序效率。**

**从堆和栈的功能和作用来通俗的比较,堆主要用来存放对象的，栈主要是用来执行程序的.**而这种不同又主要是由于堆和栈的特点决定的:

**在编程中，例如C/C++中，所有的方法调用都是通过栈来进行的,所有的局部变量,形式参数都是从栈中分配内存空间的。**

**西安达内Java培训讲师表示，实际上也不是什么分配,只是从栈顶向上用就行,就好像工厂中的传送带(conveyor belt)一样,Stack Pointer会自动指引你到放东西的位置,你所要做的只是把东西放下来就行.退出函数的时候，修改栈指针就可以把栈中的内容销毁.这样的模式速度最快,当然要用来运行程序了.**

**需要注意的是,在分配的时候,比如为一个即将要调用的程序模块分配数据区时,应事先知道这个数据区的大小,也就说是虽然分配是在程序运行时进行的,但是分配的大小多少是确定的,不变的,而这个"大小多少"是在编译时确定的,不是在运行时.**

**堆是应用程序在运行的时候请求操作系统分配给自己内存，由于从操作系统管理的内存分配,所以在分配和销毁时都要占用时间，因此用堆的效率非常低.但是堆的优点在于,编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间,因此,用堆保存数据时会得到更大的灵活性。**

**事实上,面向对象的多态性,堆内存分配是必不可少的,因为多态变量所需的存储空间只有在运行时创建了对象之后才能确定.在C++中，要求创建一个对象时，只需用new命令编制相关的代码即可。执行这些代码时，会在堆里自动进行数据的保存.当然，为达到这种灵活性，必然会付出一定的代价:在堆里分配存储空间时会花掉更长的时间!这也正是导致我们刚才所说的效率低的原因,看来列宁同志说的好,人的优点往往也是人的缺点,人的缺点往往也是人的优点。**

转自<http://jingyan.baidu.com/article/020278118b44ed1bcd9ce561.html>